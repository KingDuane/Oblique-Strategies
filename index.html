<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="manifest.json">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<meta name="theme-color" content="#1a1a1a">
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WEY424Q1JL"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-WEY424Q1JL');
</script>
<title>Oblique Strategies</title>

<!-- Open Graph / social card -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://oblique.moonshot.ooo">
<meta property="og:title" content="Oblique Strategies">
<meta property="og:description" content="Over one hundred worthwhile dilemmas by Brian Eno and Peter Schmidt.">
<meta property="og:image" content="https://oblique.moonshot.ooo/social-card.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<!-- Twitter / X -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Oblique Strategies">
<meta name="twitter:description" content="Over one hundred worthwhile dilemmas by Brian Eno and Peter Schmidt.">
<meta name="twitter:image" content="https://oblique.moonshot.ooo/social-card.png">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --card-w: min(92vw, 360px);
  --card-h: calc(var(--card-w) * 1.585);
  --radius: clamp(18px, 4.5vw, 26px);
  --top-pad: max(env(safe-area-inset-top, 0px), 20px);
  --white: #f5f5f5;
  --ink:   #111111;
  --bg:    #1a1a1a;
}

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  overscroll-behavior: none;
  background: var(--bg);
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
}

/* Full-bleed dark backdrop — extends beyond the viewport so Safari's
   rubber-band overscroll never reveals a white gap at top or bottom */
#bg {
  position: fixed;
  inset: -100px;
  background: var(--bg);
  z-index: -1;
}

/* ── Top card ── */
#top-card {
  position: fixed;
  top: var(--top-pad);
  left: 50%;
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--radius);
  z-index: 20;
  cursor: grab;
  will-change: transform;
  transform: translateX(-50%);
  /* 3-D flip container */
  perspective: 1000px;
  transform-style: preserve-3d;
}
#top-card:active { cursor: grabbing; }

/* Card faces share the same footprint */
.card-face {
  position: absolute; inset: 0;
  border-radius: var(--radius);
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--white);
  box-shadow:
    0 1px 0 rgba(255,255,255,0.5) inset,
    0 24px 60px rgba(0,0,0,0.55),
    0 8px 20px rgba(0,0,0,0.25),
    0 2px 5px rgba(0,0,0,0.15);
}

/* Front face — shows strategy text */
#face-front {
  transform: rotateY(0deg);
}

/* Back face — blank, rotated 180° so it starts hidden */
#face-back {
  transform: rotateY(180deg);
  /* Slightly warmer blank to feel like card stock */
  background: #f0f0f0;
}

/* The flip wrapper rotates the whole card */
#card-inner {
  position: absolute; inset: 0;
  transform-style: preserve-3d;
  transition: transform 0.52s cubic-bezier(0.4, 0, 0.2, 1);
  border-radius: var(--radius);
}
#card-inner.flipped {
  transform: rotateY(180deg);
}

/* Strategy text */
#strategy {
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: clamp(17px, 4.5vw, 18px);
  line-height: 1.65;
  letter-spacing: 0.005em;
  color: var(--ink);
  text-align: center;
  transform: rotate(-90deg);
  width: var(--card-h);
  padding: 0 48px;
  pointer-events: none;
  transition: opacity 0.08s;
}

/* Info text on back face — rotated to read landscape */
#info-text {
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: clamp(14px, 3.6vw, 15px);
  line-height: 1.7;
  letter-spacing: 0.008em;
  color: var(--ink);
  text-align: center;
  transform: rotate(-90deg);
  width: var(--card-h);
  padding: 0 28px;
  pointer-events: none;
}

#info-text .info-heading {
  display: block;
  font-weight: 700;
  font-size: clamp(15px, 4vw, 16px);
  letter-spacing: 0.12em;
  text-transform: uppercase;
  margin-bottom: 1em;
}

#info-text .info-title {
  display: block;
  margin-bottom: 1em;
}

#info-text .info-foot {
  display: block;
  margin-top: 1em;
}

/* ── Ghost peek cards ── */
.ghost {
  position: fixed;
  left: 50%;
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--radius);
  background: var(--white);
  pointer-events: none;
  transform-origin: center center;
}
.ghost-1 { filter: brightness(0.88); box-shadow: 0 6px 24px rgba(0,0,0,0.45); }
.ghost-2 { filter: brightness(0.76); box-shadow: 0 4px 16px rgba(0,0,0,0.35); }
.ghost-3 { filter: brightness(0.62); box-shadow: 0 3px 10px rgba(0,0,0,0.28); }
.ghost-4 { filter: brightness(0.47); }
.ghost-5 { filter: brightness(0.32); }
.ghost-6 { filter: brightness(0.18); }

/* ── Info button — lives on the front card face ── */
#info-btn {
  position: absolute;
  bottom: 14px;
  right: 16px;
  width: 22px; height: 22px;
  border-radius: 50%;
  border: 1px solid rgba(0,0,0,0.15);
  background: transparent;
  color: rgba(0,0,0,0.22);
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-size: 11px; font-weight: 400;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer;
  z-index: 10;
  transition: border-color 0.25s, color 0.25s;
  -webkit-tap-highlight-color: transparent;
}
#info-btn:hover, #info-btn:focus-visible {
  border-color: rgba(0,0,0,0.38);
  color: rgba(0,0,0,0.48);
  outline: none;
}

/* Counter */
#counter {
  position: fixed;
  right: max(env(safe-area-inset-right, 0px), 18px);
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-size: 10px; font-weight: 400;
  letter-spacing: 0.1em;
  color: rgba(255,255,255,0.18);
  z-index: 100;
  pointer-events: none;
}

/* ── Animations ── */
@keyframes exitLeft {
  0%   { transform: translateX(-50%) rotate(0deg); opacity: 1; }
  100% { transform: translateX(calc(-50% - 110vw)) rotate(-8deg); opacity: 0; }
}
@keyframes exitRight {
  0%   { transform: translateX(-50%) rotate(0deg); opacity: 1; }
  100% { transform: translateX(calc(-50% + 110vw)) rotate(8deg); opacity: 0; }
}
@keyframes enterLeft {
  from { transform: translateX(calc(-50% - 48px)); opacity: 0; }
  to   { transform: translateX(-50%); opacity: 1; }
}
@keyframes enterRight {
  from { transform: translateX(calc(-50% + 48px)); opacity: 0; }
  to   { transform: translateX(-50%); opacity: 1; }
}
@keyframes fadeIn {
  from { opacity: 0; }
  to   { opacity: 1; }
}
@keyframes idleFloat {
  0%, 100% { transform: translateX(-50%) translateY(0); }
  50%       { transform: translateX(-50%) translateY(-3px); }
}

/* Spring entrance — drop from above with damped oscillation */
@keyframes dropIn {
  0%   { transform: translateX(-50%) translateY(-72px); opacity: 0; }
  25%  { opacity: 1; }
  56%  { transform: translateX(-50%) translateY(9px);  opacity: 1; }
  71%  { transform: translateX(-50%) translateY(-4px); opacity: 1; }
  83%  { transform: translateX(-50%) translateY(2px);  opacity: 1; }
  92%  { transform: translateX(-50%) translateY(-1px); opacity: 1; }
  100% { transform: translateX(-50%) translateY(0);    opacity: 1; }
}

/* Ghost entrance — rise from below */
@keyframes ghostRise {
  from { transform: translateX(-50%) translateY(20px) rotate(var(--angle, 0deg)); opacity: 0; }
  to   { transform: translateX(-50%) translateY(0)    rotate(var(--angle, 0deg)); opacity: 1; }
}

.exit-left  { animation: exitLeft  0.36s cubic-bezier(0.4, 0, 0.8, 1) forwards; }
.exit-right { animation: exitRight 0.36s cubic-bezier(0.4, 0, 0.8, 1) forwards; }
.enter-left  { animation: enterLeft  0.32s cubic-bezier(0.2, 0, 0.3, 1) forwards; }
.enter-right { animation: enterRight 0.32s cubic-bezier(0.2, 0, 0.3, 1) forwards; }
.fade-in    { animation: fadeIn    0.22s ease forwards; }
.idle       { animation: idleFloat 4s ease-in-out infinite; }
.drop-in    { animation: dropIn    0.66s linear forwards; }
.ghost-rise { animation: ghostRise 0.38s cubic-bezier(0.2, 0, 0.3, 1) forwards; }

.lifted .card-face {
  box-shadow:
    0 1px 0 rgba(255,255,255,0.5) inset,
    0 44px 88px rgba(0,0,0,0.68),
    0 16px 38px rgba(0,0,0,0.38),
    0 4px 10px rgba(0,0,0,0.2) !important;
}

/* ── Desktop: card rotates to landscape ── */
@media (min-width: 700px) {
  :root {
    --card-w: min(58vw, 600px);
    --card-h: calc(var(--card-w) / 1.585);
    --radius: 20px;
  }
  /* Text now reads horizontally — no rotation needed */
  #strategy {
    transform: none;
    width: 100%;
    padding: 0 44px;
    font-size: 17px;
  }
  #info-text {
    transform: none;
    width: 100%;
    padding: 0 36px;
    font-size: 14px;
  }
  #info-text .info-heading {
    font-size: 13px;
  }
}

/* Loading */
#loading {
  position: fixed; inset: 0;
  background: var(--bg);
  display: flex; align-items: center; justify-content: center;
  z-index: 9999;
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-size: 10px; letter-spacing: 0.24em;
  color: rgba(255,255,255,0.18);
  transition: opacity 0.35s ease;
}
#loading.fade { opacity: 0; pointer-events: none; }
</style>
</head>
<body>

<div id="bg"></div>
<div id="loading"></div>

<!-- Ghost stack (deepest first so shallower ones paint on top) -->
<div class="ghost ghost-6" id="g6"></div>
<div class="ghost ghost-5" id="g5"></div>
<div class="ghost ghost-4" id="g4"></div>
<div class="ghost ghost-3" id="g3"></div>
<div class="ghost ghost-2" id="g2"></div>
<div class="ghost ghost-1" id="g1"></div>

<!-- Top card with flip inner -->
<div id="top-card">
  <div id="card-inner">
    <div class="card-face" id="face-front">
      <div id="strategy"></div>
      <button id="info-btn" aria-label="About Oblique Strategies">?</button>
    </div>
    <div class="card-face" id="face-back">
      <div id="info-text">
        <span class="info-heading">Oblique Strategies</span><span class="info-title">Over one hundred worthwhile dilemmas<br>by Brian Eno and Peter Schmidt.</span>
        These cards evolved from our separate observations of the principles underlying what we were doing. Sometimes they were recognized in retrospect (intellect catching up with intuition), sometimes they were identified as they were happening, sometimes they were formulated.
      </div>
    </div>
  </div>
</div>

<div id="counter"></div>

<script>
const STRATEGIES = [
  "Abandon normal instruments","Accept advice","Accretion","A line has two sides",
  "Allow an easement (an easement is the abandonment of a stricture)",
  "Are there sections? Consider transitions",
  "Ask people to work against their better judgement","Ask your body",
  "Assemble some of the instruments in a group and treat the group",
  "Be dirty","Breathe more deeply","Bridges — build — burn","Cascades",
  "Change instrument roles","Change nothing and continue with immaculate consistency",
  "Children's voices — speaking — singing","Cluster analysis",
  "Consider different fading systems","Consult other sources — promising — unpromising",
  "Convert a melodic element into a rhythmic element","Courage!","Cut a vital connection",
  "Decorate, decorate","Define an area as 'safe' and use it as an anchor",
  "Destroy — nothing — the most important thing","Discard an axiom",
  "Disconnect from desire","Discover the recipes you are using and abandon them",
  "Distorting time","Do nothing for as long as possible",
  "Don't be afraid of things because they're easy to do",
  "Don't be frightened of clichés","Don't be frightened to display your talents",
  "Don't break the silence","Don't stress one thing more than another",
  "Do something boring","Do the washing up","Do the words need changing?",
  "Emphasize differences","Emphasize repetitions","Emphasize the flaws",
  "Faced with a choice, do both",
  "Feedback recordings into the influence of the composer","Fill every beat",
  "Ghost echoes","Give the game away","Give way to your worst impulse",
  "Go slowly all the way round the outside","Honour thy error as a hidden intention",
  "How would you have done it?","Humanize something free of error","Idiot glee",
  "Imagine the music as a moving chain or caterpillar",
  "Imagine the music as a set of disconnected events",
  "In total darkness, or in a very large room, very quietly",
  "Into the impossible","Is it finished?","Is the style consistent?",
  "It is quite possible (after all)","Just carry on",
  "Left channel, right channel, centre channel","Listen to the quiet voice",
  "Look at a very small object; look at its centre",
  "Look at the order in which you do things","Lost in useless territory",
  "Make a blank valuable by putting it in an exquisite frame",
  "Make an exhaustive list of everything you might do and do the last thing on the list",
  "Make a sudden, destructive unpredictable action; incorporate",
  "Mechanize something idiosyncratic","Mute and continue",
  "Not building a wall but making a brick","Nothing is a real instrument",
  "Once the search is in progress, something will be found",
  "Only one element of each kind","Overtly resist change","Put in earplugs",
  "Question the heroic approach","Reconsider everything","Remove a restriction",
  "Remove ambiguities and convert to specifics",
  "Remove specifics and convert to ambiguities","Repetition is a form of change",
  "Restate your intent","Retrace your steps","Reverse",
  "Short circuit (example: a man eating peas with the idea that they will improve his virility shovels them straight into his lap)",
  "Simple subtraction","Slow preparation, fast execution",
  "State the problem in words as clearly as possible","Take a break",
  "Take away the elements in order of apparent non-importance",
  "The inconsistency principle","The most important thing is the thing most easily forgotten",
  "Think — inside the work — outside the work","Tidy up","Trust in the you of now",
  "Turn it upside down","Twist the spine","Use an old idea","Use an unacceptable colour",
  "Use fewer notes","Use unqualified people","Water",
  "What are you really thinking about just now?","What is the reality of the situation?",
  "What mistakes did you make last time?","What would your closest friend do?",
  "What wouldn't you do?","Work at a different speed","You are an engineer",
  "You can only make one dot at a time","Your mistake was a hidden intention"
];

// ── Constants ────────────────────────────────────────────
const NUM_GHOSTS    = 6;
// Vertical offsets for each ghost below the top card.
// Gaps compress toward the back to simulate a thick deck.
const STACK_OFFSETS = [4, 7, 10, 12, 14, 15];

// ── Elements ─────────────────────────────────────────────
const topCard   = document.getElementById('top-card');
const cardInner = document.getElementById('card-inner');
const stratEl   = document.getElementById('strategy');
const counterEl = document.getElementById('counter');
const infoBtnEl = document.getElementById('info-btn');
const ghosts    = [1,2,3,4,5,6].map(n => document.getElementById(`g${n}`));

// ── Ghost rotations — fixed random angles, set once at load ──
// Cards nearest the top are close to aligned; deeper cards are looser.
const ghostAngles = ghosts.map((_, i) => {
  const spread = i < 2 ? 1.2 : 2.0;
  return (Math.random() - 0.5) * spread * 2;
});

// ── State ────────────────────────────────────────────────
let deck      = shuffle([...STRATEGIES]);
let idx       = 0;
let busy      = false;
let showingInfo = false;
let dragging  = false;
let startX    = 0, startY = 0;
let dragX     = 0, dragY  = 0, dragT = 0;
let dragAxis  = null; // 'h' | 'v' | null
let didDrag   = false;
const HISTORY = []; // { text, idx } — capped at 10 for undo

function shuffle(a) { return a.sort(() => Math.random() - 0.5); }

// Minimum top value — set from resolved CSS before JS takes over
let safeMinTop = 20;

// ── Layout: centre the stack vertically, stack ghosts behind ─
function layout() {
  const screenH  = window.visualViewport?.height ?? window.innerHeight;
  const cardH    = topCard.offsetHeight;
  const stackH   = cardH + STACK_OFFSETS[STACK_OFFSETS.length - 1];
  const idealTop = Math.round((screenH - stackH) / 2);
  const cardTop  = Math.max(safeMinTop, idealTop);

  topCard.style.top = `${cardTop}px`;

  // Counter sits 10px below the top safe area, top-right
  counterEl.style.top = `${safeMinTop + 10}px`;

  ghosts.forEach((g, i) => {
    g.style.top    = `${cardTop + STACK_OFFSETS[i]}px`;
    g.style.zIndex = NUM_GHOSTS - i;
    g.style.setProperty('--angle', `${ghostAngles[i]}deg`);
    g.style.transform = `translateX(-50%) rotate(${ghostAngles[i]}deg)`;
  });
}

// ── Update strategy text & counter ──────────────────────
function showCard() {
  stratEl.textContent = deck[idx % deck.length];
  const rem = deck.length - (idx % deck.length);
  counterEl.textContent = `${rem}\u2009/\u2009${deck.length}`;
}

// ── Animate card entrance ────────────────────────────────
// Uses setTimeout rather than animationend — Safari doesn't reliably
// fire animationend, which would leave busy=true and deadlock the app.
function enterCard(cls) {
  const dur = cls === 'fade-in' ? 220 : 320;
  topCard.style.opacity = '0';
  topCard.classList.add(cls);
  setTimeout(() => {
    topCard.classList.remove(cls);
    topCard.style.opacity = '';
    setTimeout(() => { topCard.classList.add('idle'); busy = false; }, 80);
  }, dur);
}

// ── Flip card to show info back ──────────────────────────
function showInfo() {
  if (busy) return;
  showingInfo = true;
  topCard.classList.remove('idle');
  cardInner.classList.add('flipped');
  // Hide counter while info is showing
  counterEl.style.opacity = '0';
}

// ── Flip back to front (called on swipe-up when info showing) ─
function hideInfo(thenAdvance) {
  cardInner.classList.remove('flipped');
  counterEl.style.opacity = '';
  setTimeout(() => {
    showingInfo = false;
    if (thenAdvance) advance();
  }, 540); // wait for flip to complete
}

// ── Advance to next card ─────────────────────────────────
// dir: 'left' for swipe/click (card goes with drag), 'right' for keyboard arrow
function advance(dir = 'left') {
  if (busy) return;
  busy = true;

  HISTORY.push({ text: stratEl.textContent, idx });
  if (HISTORY.length > 10) HISTORY.shift();

  const cardTop = parseFloat(topCard.style.top);
  topCard.classList.remove('idle', 'lifted');
  topCard.style.transform = '';
  topCard.style.transition = '';
  topCard.classList.add(`exit-${dir}`);

  // Ghost stack shifts up while card exits
  const advanceOffsets = [0, ...STACK_OFFSETS.slice(0, NUM_GHOSTS - 1)];
  ghosts.forEach((g, i) => {
    g.style.transition = 'top 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
    g.style.top = `${cardTop + advanceOffsets[i]}px`;
  });

  setTimeout(() => {
    topCard.style.opacity = '0'; // stay invisible while we swap content
    topCard.classList.remove(`exit-${dir}`);
    topCard.style.transform = '';
    topCard.style.transition = '';
    idx++;
    if (idx > 0 && idx % deck.length === 0) deck = shuffle([...STRATEGIES]);
    showCard();
    ghosts.forEach(g => { g.style.transition = ''; g.style.opacity = '0'; });
    layout();
    ghosts.forEach(g => { g.style.opacity = ''; });
    enterCard('fade-in');
  }, 340);
}

// ── Undo — restore previous card ────────────────────────
// dir: 'right' for swipe-right, 'left' for keyboard left-arrow
function undo(dir = 'right') {
  if (busy || HISTORY.length === 0) return;
  busy = true;

  topCard.classList.remove('idle', 'lifted');
  topCard.style.transform = '';
  topCard.style.transition = '';
  topCard.classList.add(`exit-${dir}`);

  setTimeout(() => {
    topCard.style.opacity = '0'; // stay invisible while we swap content
    topCard.classList.remove(`exit-${dir}`);
    topCard.style.transform = '';
    topCard.style.transition = '';
    const prev = HISTORY.pop();
    idx = prev.idx;
    stratEl.textContent = prev.text;
    const rem = deck.length - (idx % deck.length);
    counterEl.textContent = `${rem}\u2009/\u2009${deck.length}`;
    layout();
    // Enter from the opposite side: if card exited right, new card comes from left
    enterCard(dir === 'right' ? 'enter-left' : 'enter-right');
  }, 340);
}

// ── Drag — Pointer Events (unifies touch + mouse, fires once each) ──
topCard.addEventListener('pointerdown', pDown);
document.addEventListener('pointermove', pMove);
document.addEventListener('pointerup',   pUp);
document.addEventListener('pointercancel', pUp);

function pDown(e) {
  if (!e.isPrimary || busy) return;
  dragging = true;
  dragX = 0; dragY = 0; dragAxis = null; didDrag = false;
  startX = e.clientX; startY = e.clientY; dragT = Date.now();
  topCard.classList.remove('idle');
  topCard.classList.add('lifted');
  topCard.style.transition = 'none';
}
function pMove(e) {
  if (!e.isPrimary || !dragging) return;
  const dx = e.clientX - startX;
  const dy = e.clientY - startY;
  if (!dragAxis && (Math.abs(dx) > 8 || Math.abs(dy) > 8)) {
    dragAxis = Math.abs(dx) > Math.abs(dy) ? 'h' : 'v';
  }
  if (dragAxis === 'h') {
    dragX = dx;
    const tilt = dx * 0.018;
    const fade = Math.max(0.3, 1 - Math.abs(dx) / 160);
    topCard.style.transform = `translateX(calc(-50% + ${dx}px)) rotate(${tilt}deg)`;
    stratEl.style.opacity = fade;
  }
}
function pUp(e) {
  if (!e.isPrimary || !dragging) return;
  dragging = false;
  topCard.classList.remove('lifted');
  topCard.style.transition = '';
  stratEl.style.opacity = '';
  const elapsed = Math.max(1, Date.now() - dragT);
  const velX = dragX / elapsed;
  if (dragAxis === 'h') {
    didDrag = true;
    if (dragX < -55 || velX < -0.4)      swipeOut('left');
    else if (dragX > 55 || velX > 0.4)   swipeOut('right');
    else { topCard.style.transform = 'translateX(-50%)'; topCard.classList.add('idle'); }
  } else {
    topCard.style.transform = 'translateX(-50%)';
    if (dragAxis) topCard.classList.add('idle');
  }
  dragX = 0; dragY = 0; dragAxis = null;
}

// ── Swipe exit — continues from drag position, no snap-back ──────────
// Uses a CSS transition (not an animation class) so the card flies off
// from wherever the finger released it rather than jumping to centre first.
function swipeOut(dir) {
  if (busy) return;
  const isUndo = dir === 'right';
  if (isUndo && HISTORY.length === 0) {
    topCard.style.transform = 'translateX(-50%)';
    topCard.classList.add('idle');
    return;
  }
  busy = true;

  if (!isUndo) {
    HISTORY.push({ text: stratEl.textContent, idx });
    if (HISTORY.length > 10) HISTORY.shift();
  }

  const cardTop = parseFloat(topCard.style.top);
  topCard.classList.remove('idle', 'lifted');

  // Transition FROM current drag position TO off-screen
  const endX = dir === 'left' ? 'calc(-50% - 110vw)' : 'calc(-50% + 110vw)';
  const endRot = dir === 'left' ? -8 : 8;
  topCard.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.8, 1), opacity 0.3s ease';
  topCard.style.transform = `translateX(${endX}) rotate(${endRot}deg)`;
  topCard.style.opacity = '0';

  if (!isUndo) {
    const advanceOffsets = [0, ...STACK_OFFSETS.slice(0, NUM_GHOSTS - 1)];
    ghosts.forEach((g, i) => {
      g.style.transition = 'top 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      g.style.top = `${cardTop + advanceOffsets[i]}px`;
    });
  }

  setTimeout(() => {
    topCard.style.transition = '';
    topCard.style.transform = '';
    // opacity stays 0 — enterCard animates it back to 1
    if (isUndo) {
      const prev = HISTORY.pop();
      idx = prev.idx;
      stratEl.textContent = prev.text;
      const rem = deck.length - (idx % deck.length);
      counterEl.textContent = `${rem}\u2009/\u2009${deck.length}`;
    } else {
      idx++;
      if (idx > 0 && idx % deck.length === 0) deck = shuffle([...STRATEGIES]);
      showCard();
      ghosts.forEach(g => { g.style.transition = ''; g.style.opacity = '0'; });
    }
    layout();
    ghosts.forEach(g => { g.style.opacity = ''; });
    enterCard(isUndo ? 'enter-left' : 'fade-in');
  }, 300);
}

// Tap — advance (unless it was a drag that didn't meet threshold)
topCard.addEventListener('click', () => {
  if (busy) return;
  if (didDrag) { didDrag = false; return; }
  if (showingInfo) hideInfo(false);
  else advance('right');
});

// Keyboard — arrow direction matches card exit direction
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowRight' || e.key === ' ') {
    if (showingInfo) hideInfo(true); else advance('right');
  }
  if (e.key === 'ArrowLeft' || e.key === 'z' || e.key === 'Z') undo('left');
  if (e.key === 'i' || e.key === 'I') showInfo();
});

// ── Info button: flip to back (lives on front face only) ─
infoBtnEl.addEventListener('click', (e) => {
  e.stopPropagation(); // don't bubble to topCard's advance() handler
  if (!showingInfo) showInfo();
});

// ── Boot ─────────────────────────────────────────────────
window.addEventListener('load', () => {
  // Capture resolved safe-area top before JS overrides style.top
  safeMinTop = parseFloat(getComputedStyle(topCard).top) || 20;

  // Hide card and ghosts behind the loading overlay
  topCard.style.opacity = '0';
  ghosts.forEach(g => { g.style.opacity = '0'; });

  layout();
  showCard();
  window.addEventListener('resize', layout);
  window.visualViewport?.addEventListener('resize', layout);

  const loading = document.getElementById('loading');

  setTimeout(() => {
    // Fade out the dark overlay
    loading.classList.add('fade');
    setTimeout(() => loading.remove(), 400);

    // Spring-drop the top card in
    topCard.style.opacity = '';
    topCard.classList.add('drop-in');
    topCard.addEventListener('animationend', () => {
      topCard.classList.remove('drop-in');
      setTimeout(() => topCard.classList.add('idle'), 80);
    }, { once: true });

    // Stagger ghost cards rising from below
    ghosts.forEach((g, i) => {
      setTimeout(() => {
        g.style.opacity = '';
        g.classList.add('ghost-rise');
        g.addEventListener('animationend', () =>
          g.classList.remove('ghost-rise'), { once: true });
      }, i * 65);
    });
  }, 700);
});
</script>
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () =>
    navigator.serviceWorker.register('/sw.js'));
}
</script>
</body>
</html>