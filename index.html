<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icons/icon.svg">
<meta name="theme-color" content="#1a1a1a">
<title>Oblique Strategies</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --card-w: min(92vw, 360px);
  --card-h: calc(var(--card-w) * 1.585);
  --radius: clamp(18px, 4.5vw, 26px);
  --top-pad: max(env(safe-area-inset-top, 0px), 20px);
  --white: #f5f5f5;
  --ink:   #111111;
  --bg:    #1a1a1a;
}

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  overscroll-behavior: none;
  background: var(--bg);
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
}

/* Full-bleed dark backdrop — extends beyond the viewport so Safari's
   rubber-band overscroll never reveals a white gap at top or bottom */
#bg {
  position: fixed;
  inset: -100px;
  background: var(--bg);
  z-index: -1;
}

/* ── Top card ── */
#top-card {
  position: fixed;
  top: var(--top-pad);
  left: 50%;
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--radius);
  z-index: 20;
  cursor: grab;
  will-change: transform;
  transform: translateX(-50%);
  /* 3-D flip container */
  perspective: 1000px;
  transform-style: preserve-3d;
}
#top-card:active { cursor: grabbing; }

/* Card faces share the same footprint */
.card-face {
  position: absolute; inset: 0;
  border-radius: var(--radius);
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--white);
  box-shadow:
    0 1px 0 rgba(255,255,255,0.5) inset,
    0 24px 60px rgba(0,0,0,0.55),
    0 8px 20px rgba(0,0,0,0.25),
    0 2px 5px rgba(0,0,0,0.15);
}

/* Front face — shows strategy text */
#face-front {
  transform: rotateY(0deg);
}

/* Back face — blank, rotated 180° so it starts hidden */
#face-back {
  transform: rotateY(180deg);
  /* Slightly warmer blank to feel like card stock */
  background: #f0f0f0;
}

/* The flip wrapper rotates the whole card */
#card-inner {
  position: absolute; inset: 0;
  transform-style: preserve-3d;
  transition: transform 0.52s cubic-bezier(0.4, 0, 0.2, 1);
  border-radius: var(--radius);
}
#card-inner.flipped {
  transform: rotateY(180deg);
}

/* Strategy text */
#strategy {
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: clamp(17px, 4.5vw, 18px);
  line-height: 1.65;
  letter-spacing: 0.005em;
  color: var(--ink);
  text-align: center;
  transform: rotate(-90deg);
  width: var(--card-h);
  padding: 0 48px;
  pointer-events: none;
  transition: opacity 0.08s;
}

/* Info text on back face — rotated to read landscape */
#info-text {
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: clamp(14px, 3.6vw, 15px);
  line-height: 1.7;
  letter-spacing: 0.008em;
  color: var(--ink);
  text-align: center;
  transform: rotate(-90deg);
  width: var(--card-h);
  padding: 0 28px;
  pointer-events: none;
}

#info-text .info-heading {
  display: block;
  font-weight: 700;
  font-size: clamp(15px, 4vw, 16px);
  letter-spacing: 0.12em;
  text-transform: uppercase;
  margin-bottom: 1em;
}

#info-text .info-title {
  display: block;
  margin-bottom: 1em;
}

#info-text .info-foot {
  display: block;
  margin-top: 1em;
}

/* ── Ghost peek cards ── */
.ghost {
  position: fixed;
  left: 50%;
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--radius);
  background: var(--white);
  pointer-events: none;
  transform-origin: center center;
}
.ghost-1 { filter: brightness(0.88); box-shadow: 0 6px 24px rgba(0,0,0,0.45); }
.ghost-2 { filter: brightness(0.76); box-shadow: 0 4px 16px rgba(0,0,0,0.35); }
.ghost-3 { filter: brightness(0.62); box-shadow: 0 3px 10px rgba(0,0,0,0.28); }
.ghost-4 { filter: brightness(0.47); }
.ghost-5 { filter: brightness(0.32); }
.ghost-6 { filter: brightness(0.18); }

/* ── Info button ── */
#info-btn {
  position: fixed;
  bottom: max(env(safe-area-inset-bottom, 0px) + 16px, 24px);
  left: 50%;
  transform: translateX(-50%);
  width: 26px; height: 26px;
  border-radius: 50%;
  border: 1px solid rgba(255,255,255,0.18);
  background: transparent;
  color: rgba(255,255,255,0.2);
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-size: 11px; font-weight: 400;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer;
  z-index: 10;
  transition: border-color 0.25s, color 0.25s;
  -webkit-tap-highlight-color: transparent;
}
#info-btn:hover, #info-btn:focus-visible {
  border-color: rgba(255,255,255,0.42);
  color: rgba(255,255,255,0.48);
  outline: none;
}

/* Counter */
#counter {
  position: fixed;
  right: max(env(safe-area-inset-right, 0px), 18px);
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-size: 10px; font-weight: 400;
  letter-spacing: 0.1em;
  color: rgba(255,255,255,0.18);
  z-index: 100;
  pointer-events: none;
}

/* ── Animations ── */
@keyframes flyUp {
  0%   { transform: translateX(-50%) translateY(0) rotate(0deg); opacity: 1; }
  18%  { transform: translateX(-50%) translateY(-18px) rotate(-0.8deg); opacity: 1; }
  100% { transform: translateX(-50%) translateY(-130%) rotate(-3deg); opacity: 0; }
}
@keyframes riseUp {
  0%   { transform: translateX(-50%) translateY(28px); opacity: 0.35; }
  100% { transform: translateX(-50%) translateY(0); opacity: 1; }
}
@keyframes idleFloat {
  0%, 100% { transform: translateX(-50%) translateY(0); }
  50%       { transform: translateX(-50%) translateY(-3px); }
}

/* Spring entrance — drop from above with damped oscillation */
@keyframes dropIn {
  0%   { transform: translateX(-50%) translateY(-72px); opacity: 0; }
  25%  { opacity: 1; }
  56%  { transform: translateX(-50%) translateY(9px);  opacity: 1; }
  71%  { transform: translateX(-50%) translateY(-4px); opacity: 1; }
  83%  { transform: translateX(-50%) translateY(2px);  opacity: 1; }
  92%  { transform: translateX(-50%) translateY(-1px); opacity: 1; }
  100% { transform: translateX(-50%) translateY(0);    opacity: 1; }
}

/* Ghost entrance — rise from below */
@keyframes ghostRise {
  from { transform: translateX(-50%) translateY(20px) rotate(var(--angle, 0deg)); opacity: 0; }
  to   { transform: translateX(-50%) translateY(0)    rotate(var(--angle, 0deg)); opacity: 1; }
}

.fly-up     { animation: flyUp     0.42s cubic-bezier(0.4, 0, 0.6, 1) forwards; }
.rise-up    { animation: riseUp    0.44s cubic-bezier(0.34, 1.4, 0.64, 1) forwards; }
.idle       { animation: idleFloat 4s ease-in-out infinite; }
.drop-in    { animation: dropIn    0.66s linear forwards; }
.ghost-rise { animation: ghostRise 0.38s cubic-bezier(0.2, 0, 0.3, 1) forwards; }

.lifted .card-face {
  box-shadow:
    0 1px 0 rgba(255,255,255,0.5) inset,
    0 44px 88px rgba(0,0,0,0.68),
    0 16px 38px rgba(0,0,0,0.38),
    0 4px 10px rgba(0,0,0,0.2) !important;
}

/* Loading */
#loading {
  position: fixed; inset: 0;
  background: var(--bg);
  display: flex; align-items: center; justify-content: center;
  z-index: 9999;
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-size: 10px; letter-spacing: 0.24em;
  color: rgba(255,255,255,0.18);
  transition: opacity 0.35s ease;
}
#loading.fade { opacity: 0; pointer-events: none; }
</style>
</head>
<body>

<div id="bg"></div>
<div id="loading"></div>

<!-- Ghost stack (deepest first so shallower ones paint on top) -->
<div class="ghost ghost-6" id="g6"></div>
<div class="ghost ghost-5" id="g5"></div>
<div class="ghost ghost-4" id="g4"></div>
<div class="ghost ghost-3" id="g3"></div>
<div class="ghost ghost-2" id="g2"></div>
<div class="ghost ghost-1" id="g1"></div>

<!-- Top card with flip inner -->
<div id="top-card">
  <div id="card-inner">
    <div class="card-face" id="face-front">
      <div id="strategy"></div>
    </div>
    <div class="card-face" id="face-back">
      <div id="info-text">
        <span class="info-heading">Oblique Strategies</span><span class="info-title">Over one hundred worthwhile dilemmas<br>by Brian Eno and Peter Schmidt.</span>
        These cards evolved from our separate observations of the principles underlying what we were doing. Sometimes they were recognized in retrospect (intellect catching up with intuition), sometimes they were identified as they were happening, sometimes they were formulated.
      </div>
    </div>
  </div>
</div>

<div id="counter"></div>
<button id="info-btn" aria-label="About Oblique Strategies">?</button>

<script>
const STRATEGIES = [
  "Abandon normal instruments","Accept advice","Accretion","A line has two sides",
  "Allow an easement (an easement is the abandonment of a stricture)",
  "Are there sections? Consider transitions",
  "Ask people to work against their better judgement","Ask your body",
  "Assemble some of the instruments in a group and treat the group",
  "Be dirty","Breathe more deeply","Bridges — build — burn","Cascades",
  "Change instrument roles","Change nothing and continue with immaculate consistency",
  "Children's voices — speaking — singing","Cluster analysis",
  "Consider different fading systems","Consult other sources — promising — unpromising",
  "Convert a melodic element into a rhythmic element","Courage!","Cut a vital connection",
  "Decorate, decorate","Define an area as 'safe' and use it as an anchor",
  "Destroy — nothing — the most important thing","Discard an axiom",
  "Disconnect from desire","Discover the recipes you are using and abandon them",
  "Distorting time","Do nothing for as long as possible",
  "Don't be afraid of things because they're easy to do",
  "Don't be frightened of clichés","Don't be frightened to display your talents",
  "Don't break the silence","Don't stress one thing more than another",
  "Do something boring","Do the washing up","Do the words need changing?",
  "Emphasize differences","Emphasize repetitions","Emphasize the flaws",
  "Faced with a choice, do both",
  "Feedback recordings into the influence of the composer","Fill every beat",
  "Ghost echoes","Give the game away","Give way to your worst impulse",
  "Go slowly all the way round the outside","Honour thy error as a hidden intention",
  "How would you have done it?","Humanize something free of error","Idiot glee",
  "Imagine the music as a moving chain or caterpillar",
  "Imagine the music as a set of disconnected events",
  "In total darkness, or in a very large room, very quietly",
  "Into the impossible","Is it finished?","Is the style consistent?",
  "It is quite possible (after all)","Just carry on",
  "Left channel, right channel, centre channel","Listen to the quiet voice",
  "Look at a very small object; look at its centre",
  "Look at the order in which you do things","Lost in useless territory",
  "Make a blank valuable by putting it in an exquisite frame",
  "Make an exhaustive list of everything you might do and do the last thing on the list",
  "Make a sudden, destructive unpredictable action; incorporate",
  "Mechanize something idiosyncratic","Mute and continue",
  "Not building a wall but making a brick","Nothing is a real instrument",
  "Once the search is in progress, something will be found",
  "Only one element of each kind","Overtly resist change","Put in earplugs",
  "Question the heroic approach","Reconsider everything","Remove a restriction",
  "Remove ambiguities and convert to specifics",
  "Remove specifics and convert to ambiguities","Repetition is a form of change",
  "Restate your intent","Retrace your steps","Reverse",
  "Short circuit (example: a man eating peas with the idea that they will improve his virility shovels them straight into his lap)",
  "Simple subtraction","Slow preparation, fast execution",
  "State the problem in words as clearly as possible","Take a break",
  "Take away the elements in order of apparent non-importance",
  "The inconsistency principle","The most important thing is the thing most easily forgotten",
  "Think — inside the work — outside the work","Tidy up","Trust in the you of now",
  "Turn it upside down","Twist the spine","Use an old idea","Use an unacceptable colour",
  "Use fewer notes","Use unqualified people","Water",
  "What are you really thinking about just now?","What is the reality of the situation?",
  "What mistakes did you make last time?","What would your closest friend do?",
  "What wouldn't you do?","Work at a different speed","You are an engineer",
  "You can only make one dot at a time","Your mistake was a hidden intention"
];

// ── Constants ────────────────────────────────────────────
const NUM_GHOSTS    = 6;
// Vertical offsets for each ghost below the top card.
// Gaps compress toward the back to simulate a thick deck.
const STACK_OFFSETS = [4, 7, 10, 12, 14, 15];

// ── Elements ─────────────────────────────────────────────
const topCard   = document.getElementById('top-card');
const cardInner = document.getElementById('card-inner');
const stratEl   = document.getElementById('strategy');
const counterEl = document.getElementById('counter');
const infoBtnEl = document.getElementById('info-btn');
const ghosts    = [1,2,3,4,5,6].map(n => document.getElementById(`g${n}`));

// ── Ghost rotations — fixed random angles, set once at load ──
// Cards nearest the top are close to aligned; deeper cards are looser.
const ghostAngles = ghosts.map((_, i) => {
  const spread = i < 2 ? 1.2 : 2.0;
  return (Math.random() - 0.5) * spread * 2;
});

// ── State ────────────────────────────────────────────────
let deck      = shuffle([...STRATEGIES]);
let idx       = 0;
let busy      = false;
let showingInfo = false;
let dragging  = false;
let startY    = 0, dragY = 0, dragT = 0;

function shuffle(a) { return a.sort(() => Math.random() - 0.5); }

// Minimum top value — set from resolved CSS before JS takes over
let safeMinTop = 20;

// ── Layout: centre the stack vertically, stack ghosts behind ─
function layout() {
  const screenH  = window.visualViewport?.height ?? window.innerHeight;
  const cardH    = topCard.offsetHeight;
  const stackH   = cardH + STACK_OFFSETS[STACK_OFFSETS.length - 1];
  const idealTop = Math.round((screenH - stackH) / 2);
  const cardTop  = Math.max(safeMinTop, idealTop);

  topCard.style.top = `${cardTop}px`;

  // Counter sits 10px below the top safe area, top-right
  counterEl.style.top = `${safeMinTop + 10}px`;

  ghosts.forEach((g, i) => {
    g.style.top    = `${cardTop + STACK_OFFSETS[i]}px`;
    g.style.zIndex = NUM_GHOSTS - i;
    g.style.setProperty('--angle', `${ghostAngles[i]}deg`);
    g.style.transform = `translateX(-50%) rotate(${ghostAngles[i]}deg)`;
  });
}

// ── Update strategy text & counter ──────────────────────
function showCard(animate) {
  stratEl.textContent = deck[idx % deck.length];
  const rem = deck.length - (idx % deck.length);
  counterEl.textContent = `${rem}\u2009/\u2009${deck.length}`;
  if (animate) {
    topCard.classList.remove('rise-up');
    void topCard.offsetWidth;
    topCard.classList.add('rise-up');
    setTimeout(() => topCard.classList.remove('rise-up'), 460);
  }
}

// ── Flip card to show info back ──────────────────────────
function showInfo() {
  if (busy) return;
  showingInfo = true;
  topCard.classList.remove('idle');
  cardInner.classList.add('flipped');
  // Hide counter while info is showing
  counterEl.style.opacity = '0';
}

// ── Flip back to front (called on swipe-up when info showing) ─
function hideInfo(thenAdvance) {
  cardInner.classList.remove('flipped');
  counterEl.style.opacity = '';
  setTimeout(() => {
    showingInfo = false;
    if (thenAdvance) advance();
  }, 540); // wait for flip to complete
}

// ── Advance to next card ─────────────────────────────────
function advance() {
  if (busy) return;
  busy = true;

  // Read position before touching any styles
  const cardTop = parseFloat(topCard.style.top);

  topCard.classList.remove('idle', 'lifted');
  topCard.style.transform = '';
  topCard.style.transition = '';
  topCard.classList.add('fly-up');

  // Shift ghost stack up: ghost[0] → card position, rest step forward
  const advanceOffsets = [0, ...STACK_OFFSETS.slice(0, NUM_GHOSTS - 1)];
  ghosts.forEach((g, i) => {
    g.style.transition = 'top 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
    g.style.top = `${cardTop + advanceOffsets[i]}px`;
  });

  setTimeout(() => {
    topCard.classList.remove('fly-up');
    topCard.style.transform = '';
    topCard.style.transition = '';
    idx++;
    if (idx > 0 && idx % deck.length === 0) deck = shuffle([...STRATEGIES]);
    showCard(true);
    ghosts.forEach(g => { g.style.transition = ''; });
    layout();
    setTimeout(() => { topCard.classList.add('idle'); busy = false; }, 480);
  }, 420);
}

// ── Drag ─────────────────────────────────────────────────
topCard.addEventListener('mousedown',  pDown);
topCard.addEventListener('touchstart', pDown, { passive: true });
document.addEventListener('mousemove', pMove);
document.addEventListener('touchmove', pMove, { passive: true });
document.addEventListener('mouseup',   pUp);
document.addEventListener('touchend',  pUp);

function pDown(e) {
  if (busy) return;
  dragging = true; dragY = 0;
  const pt = e.touches ? e.touches[0] : e;
  startY = pt.clientY; dragT = Date.now();
  topCard.classList.remove('idle');
  topCard.classList.add('lifted');
  topCard.style.transition = 'none';
}
function pMove(e) {
  if (!dragging) return;
  const pt = e.touches ? e.touches[0] : e;
  dragY = pt.clientY - startY;
  const dy  = Math.min(dragY, 20);
  const tilt = dy * -0.014;
  const fade = Math.max(0.25, 1 - Math.max(0, -dy) / 100);
  topCard.style.transform = `translateX(-50%) translateY(${dy}px) rotate(${tilt}deg)`;
  stratEl.style.opacity = fade;
}
function pUp() {
  if (!dragging) return;
  dragging = false;
  topCard.classList.remove('lifted');
  topCard.style.transition = '';
  stratEl.style.opacity = '';
  const vel = dragY / (Date.now() - dragT);
  if (dragY < -55 || vel < -0.35) {
    // Swiped up — if info card showing, flip back then advance; else advance
    if (showingInfo) {
      hideInfo(true);
    } else {
      advance();
    }
  } else {
    topCard.style.transform = 'translateX(-50%)';
    topCard.classList.add('idle');
  }
  dragY = 0;
}

// Tap — if showing info, flip back; else advance
topCard.addEventListener('click', () => {
  if (busy) return;
  if (showingInfo) {
    hideInfo(false);
  } else if (Math.abs(dragY) < 6) {
    advance();
  }
});

// Keyboard
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowUp' || e.key === ' ' || e.key === 'ArrowRight') {
    if (showingInfo) hideInfo(true); else advance();
  }
  if (e.key === 'i' || e.key === 'I') showInfo();
});

// ── Info button: flip the top card to reveal back ────────
infoBtnEl.addEventListener('click', () => {
  if (showingInfo) {
    hideInfo(false);
  } else {
    showInfo();
  }
});

// ── Boot ─────────────────────────────────────────────────
window.addEventListener('load', () => {
  // Capture resolved safe-area top before JS overrides style.top
  safeMinTop = parseFloat(getComputedStyle(topCard).top) || 20;

  // Hide card and ghosts behind the loading overlay
  topCard.style.opacity = '0';
  ghosts.forEach(g => { g.style.opacity = '0'; });

  layout();
  showCard(false);
  window.addEventListener('resize', layout);
  window.visualViewport?.addEventListener('resize', layout);

  const loading = document.getElementById('loading');

  setTimeout(() => {
    // Fade out the dark overlay
    loading.classList.add('fade');
    setTimeout(() => loading.remove(), 400);

    // Spring-drop the top card in
    topCard.style.opacity = '';
    topCard.classList.add('drop-in');
    topCard.addEventListener('animationend', () => {
      topCard.classList.remove('drop-in');
      setTimeout(() => topCard.classList.add('idle'), 80);
    }, { once: true });

    // Stagger ghost cards rising from below
    ghosts.forEach((g, i) => {
      setTimeout(() => {
        g.style.opacity = '';
        g.classList.add('ghost-rise');
        g.addEventListener('animationend', () =>
          g.classList.remove('ghost-rise'), { once: true });
      }, i * 65);
    });
  }, 700);
});
</script>
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () =>
    navigator.serviceWorker.register('/sw.js'));
}
</script>
</body>
</html>